# OpenMEEG: Electromagnetic Forward Problem Solver for MEG/EEG

## Overview

OpenMEEG is a comprehensive C++ software package for solving the electromagnetic forward problem in MEG (magnetoencephalography) and EEG (electroencephalography). The forward problem involves computing how electrical currents generated by neural sources in the brain propagate through different tissue compartments (brain, cerebrospinal fluid, skull, scalp) to produce the electromagnetic fields measured at MEG sensors or electrical potentials recorded at EEG electrodes. OpenMEEG uses the Boundary Element Method (BEM) to accurately model volume conduction in realistic, MRI-derived head geometries with multiple tissue layers.

The forward problem is foundational for source localization: before estimating where neural activity originates (the inverse problem), we must understand how sources at different locations would produce specific sensor patterns. OpenMEEG excels at this by computing lead field matrices - precomputed maps showing how unit sources at each location would be measured by each sensor. These lead fields enable accurate dipole fitting, distributed source imaging, and beamforming. OpenMEEG's symmetric BEM formulation is computationally efficient and numerically stable, making it suitable for high-resolution source spaces and complex head models.

**Key Features:**
- Boundary Element Method (BEM) for volume conduction modeling
- Realistic head models from MRI segmentation (3-layer, 4-layer, or more)
- Accurate lead field matrix computation for source localization
- Support for both MEG and EEG modalities
- Symmetric BEM formulation for computational efficiency
- Anisotropic conductivity modeling (e.g., white matter)
- Integration with major MEG/EEG analysis platforms (MNE-Python, FieldTrip, Brainstorm)
- Python and MATLAB interfaces
- Parallel computation support
- Validated against analytical solutions

**Primary Use Cases:**
- MEG and EEG source localization studies
- Clinical epilepsy focus identification
- Pre-surgical planning for epilepsy or tumor resection
- Brain-computer interface development
- Validating and comparing inverse methods
- Developing new source imaging algorithms
- Multi-modal MEG/EEG fusion
- Realistic simulation studies

**Citation:**
```
Gramfort, A., Papadopoulo, T., Olivi, E., & Clerc, M. (2010). OpenMEEG: opensource
software for quasistatic bioelectromagnetics. BioMedical Engineering OnLine, 9(1), 45.
```

## Installation

### Binary Installation (Recommended)

```bash
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install openmeeg

# macOS (via Homebrew)
brew tap openmeeg/openmeeg
brew install openmeeg

# Verify installation
om_assemble --version
# Expected output: OpenMEEG version 2.5.x
```

### Python Package Installation

```bash
# Install OpenMEEG Python bindings
pip install openmeeg

# Verify Python interface
python -c "import openmeeg; print(openmeeg.__version__)"

# Install with MNE-Python for integration
pip install mne
```

### MATLAB Interface

```matlab
% Download OpenMEEG MATLAB toolbox from:
% https://github.com/openmeeg/openmeeg_matlab

% Add to MATLAB path
addpath('/path/to/openmeeg_matlab');

% Test MATLAB interface
om_version
```

### Building from Source (Advanced)

```bash
# Install dependencies
sudo apt-get install cmake g++ git libblas-dev liblapack-dev

# Clone repository
git clone https://github.com/openmeeg/openmeeg.git
cd openmeeg

# Build
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j4
sudo make install

# Test installation
om_assemble --help
```

### Docker Container

```bash
# Pull OpenMEEG Docker image
docker pull openmeeg/openmeeg

# Run OpenMEEG in container
docker run -it --rm \
  -v $(pwd):/data \
  openmeeg/openmeeg \
  om_assemble -h
```

## Head Model Creation

**Example 1: Basic 3-Layer BEM Model**

```python
import mne
from mne.bem import make_bem_model, make_bem_solution

# Assuming FreeSurfer reconstruction completed
subject = 'sub-001'
subjects_dir = '/path/to/freesurfer/subjects'

# Create 3-layer BEM surfaces (inner skull, outer skull, outer skin)
# Conductivities: brain=0.3 S/m, skull=0.006 S/m, scalp=0.3 S/m
conductivity = (0.3, 0.006, 0.3)

bem_model = make_bem_model(
    subject=subject,
    ico=4,  # Icosahedron subdivision (5120 triangles per surface)
    conductivity=conductivity,
    subjects_dir=subjects_dir
)

# Visualize BEM surfaces
mne.viz.plot_bem(subject=subject, subjects_dir=subjects_dir,
                 orientation='coronal')

print(f"BEM surfaces created:")
for surf in bem_model:
    print(f"  {surf['id']}: {surf['np']} vertices, {surf['ntri']} triangles")
```

**Example 2: 4-Layer BEM with CSF**

```python
# More accurate model including CSF compartment
# Layers: brain (inner skull), CSF, skull, scalp
conductivity_4layer = (0.3, 1.7, 0.006, 0.3)  # Brain, CSF, Skull, Scalp

# Requires additional segmentation for CSF surface
# Typically done with FreeSurfer or custom segmentation

bem_model_4layer = make_bem_model(
    subject='sub-001',
    ico=4,
    conductivity=conductivity_4layer,
    subjects_dir=subjects_dir
)

# 4-layer models provide more accurate forward solutions
# Especially important for deep sources and high-frequency activity
```

**Example 3: Creating BEM Solution (Forward Operator)**

```python
# Compute BEM solution using OpenMEEG
bem_solution = make_bem_solution(
    bem_model,
    solver='openmeeg'  # Use OpenMEEG as backend
)

# Save BEM solution for future use
bem_fname = f'{subjects_dir}/{subject}/bem/{subject}-bem-sol.fif'
mne.write_bem_solution(bem_fname, bem_solution)

print("BEM solution computed and saved")
print(f"Method: {bem_solution['solver']}")
print(f"Number of surfaces: {len(bem_solution['surfs'])}")
```

**Example 4: Quality Control - Surface Visualization**

```python
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Extract surface vertices and triangles
inner_skull = bem_model[0]
vertices = inner_skull['rr']  # Vertices (N, 3)
triangles = inner_skull['tris']  # Triangles (M, 3)

# 3D visualization
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

# Plot surface mesh
ax.plot_trisurf(
    vertices[:, 0], vertices[:, 1], vertices[:, 2],
    triangles=triangles,
    color='lightblue',
    alpha=0.5,
    edgecolor='gray',
    linewidth=0.2
)

ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_zlabel('Z (m)')
ax.set_title('Inner Skull BEM Surface')
plt.savefig('bem_surface.png', dpi=300)
```

## Forward Solution Computation

**Example 5: Computing Lead Field Matrix**

```python
import mne
import numpy as np

# Load BEM solution
bem_solution = mne.read_bem_solution(
    f'{subjects_dir}/{subject}/bem/{subject}-bem-sol.fif'
)

# Define source space (cortical surface sources)
src = mne.setup_source_space(
    subject=subject,
    spacing='oct6',  # ~4.9mm spacing
    subjects_dir=subjects_dir,
    add_dist=False
)

print(f"Source space: {src}")
print(f"Left hemisphere: {src[0]['nuse']} sources")
print(f"Right hemisphere: {src[1]['nuse']} sources")

# Load MEG/EEG sensor information
raw = mne.io.read_raw_fif('sub-001_raw.fif', preload=False)
raw.info['bads'] = []  # Mark bad channels if needed

# Compute forward solution (lead field matrix)
fwd = mne.make_forward_solution(
    raw.info,
    trans='sub-001-trans.fif',  # Head-to-MRI transformation
    src=src,
    bem=bem_solution,
    meg=True,  # Include MEG
    eeg=True,  # Include EEG
    mindist=5.0,  # Minimum distance from inner skull (mm)
    n_jobs=4  # Parallel computation
)

# Save forward solution
mne.write_forward_solution('sub-001-fwd.fif', fwd, overwrite=True)

print(f"\nForward solution computed:")
print(f"MEG channels: {fwd['info']['nchan'] - len(mne.pick_types(fwd['info'], meg=False, eeg=True))}")
print(f"EEG channels: {len(mne.pick_types(fwd['info'], meg=False, eeg=True))}")
print(f"Source locations: {fwd['nsource']}")
```

**Example 6: EEG-Only Forward Model**

```python
# For EEG-only studies
fwd_eeg = mne.make_forward_solution(
    raw.info,
    trans='sub-001-trans.fif',
    src=src,
    bem=bem_solution,
    meg=False,  # Exclude MEG
    eeg=True,
    mindist=5.0
)

# Convert to surface orientation (normal to cortex)
fwd_eeg_surf = mne.convert_forward_solution(
    fwd_eeg,
    surf_ori=True,
    force_fixed=True
)

print("EEG forward solution:")
print(f"Channels: {len(mne.pick_types(fwd_eeg['info'], eeg=True))}")
print(f"Orientation: {'Fixed' if fwd_eeg_surf['surf_ori'] else 'Free'}")
```

**Example 7: MEG-Only Forward Model**

```python
# For MEG-only studies
fwd_meg = mne.make_forward_solution(
    raw.info,
    trans='sub-001-trans.fif',
    src=src,
    bem=bem_solution,
    meg=True,
    eeg=False,
    mindist=5.0
)

# MEG is less sensitive to skull conductivity
# Can use simpler 1-layer (inner skull) model for MEG
bem_meg = make_bem_model(
    subject=subject,
    ico=4,
    conductivity=(0.3,),  # Single compartment
    subjects_dir=subjects_dir
)
bem_sol_meg = make_bem_solution(bem_meg)

fwd_meg_simple = mne.make_forward_solution(
    raw.info,
    trans='sub-001-trans.fif',
    src=src,
    bem=bem_sol_meg,
    meg=True,
    eeg=False
)
```

**Example 8: Visualizing Lead Fields**

```python
# Visualize topography for a single source
import matplotlib.pyplot as plt

# Pick a source location (e.g., left motor cortex)
source_idx = 1500  # Index of source

# Extract lead field for this source
leadfield = fwd['sol']['data']  # (n_channels, 3*n_sources)
lf_source = leadfield[:, source_idx*3:(source_idx+1)*3]  # 3 orientations

# Take normal component if surface-oriented
if fwd['surf_ori']:
    lf_source = lf_source[:, 2]  # Normal component
else:
    lf_source = np.linalg.norm(lf_source, axis=1)  # Magnitude

# Create evoked object for visualization
info = fwd['info']
evoked = mne.EvokedArray(lf_source[:, np.newaxis], info, tmin=0)

# Plot topography
if 'meg' in [mne.io.pick.channel_type(info, i) for i in range(info['nchan'])]:
    evoked.plot_topomap(times=0, ch_type='mag', title='MEG Lead Field')

if 'eeg' in [mne.io.pick.channel_type(info, i) for i in range(info['nchan'])]:
    evoked.plot_topomap(times=0, ch_type='eeg', title='EEG Lead Field')
```

## Integration with MNE-Python

**Example 9: Complete Source Localization Pipeline**

```python
import mne
from mne.minimum_norm import make_inverse_operator, apply_inverse

# 1. Load forward solution computed with OpenMEEG
fwd = mne.read_forward_solution('sub-001-fwd.fif')

# 2. Load preprocessed evoked data
evoked = mne.read_evokeds('sub-001-ave.fif', condition='auditory/left')[0]

# 3. Compute noise covariance (from baseline or empty room)
noise_cov = mne.compute_covariance(
    epochs, tmax=0,  # Baseline period
    method='empirical'
)

# 4. Create inverse operator
inverse_operator = make_inverse_operator(
    evoked.info,
    fwd,
    noise_cov,
    loose=0.2,  # Loose orientation constraint
    depth=0.8   # Depth weighting
)

# 5. Apply inverse solution (minimum norm estimate)
stc = apply_inverse(
    evoked,
    inverse_operator,
    lambda2=1.0 / 9.0,  # Regularization parameter
    method='dSPM',  # Dynamic statistical parametric mapping
    pick_ori=None
)

# 6. Visualize source estimate
brain = stc.plot(
    subject=subject,
    subjects_dir=subjects_dir,
    hemi='both',
    time_viewer=True,
    initial_time=0.08,  # Peak latency
    clim=dict(kind='value', lims=[3, 6, 9])
)
```

**Example 10: Dipole Fitting**

```python
from mne.forward import make_forward_dipole
from mne.dipole import fit_dipole

# Fit dipole to evoked response (e.g., N100 peak)
evoked = mne.read_evokeds('sub-001-ave.fif')[0]

# Crop to peak latency
evoked_crop = evoked.copy().crop(0.08, 0.12)

# Fit dipole
dip = fit_dipole(
    evoked_crop,
    noise_cov,
    bem_solution,
    trans='sub-001-trans.fif',
    n_jobs=4
)[0]

# Plot dipole location
dip.plot_locations(
    trans='sub-001-trans.fif',
    subject=subject,
    subjects_dir=subjects_dir,
    mode='orthoview'
)

print(f"Best fitting dipole:")
print(f"  Position: {dip.pos[0]} (m)")
print(f"  GOF: {dip.gof[0]:.1f}%")
print(f"  Orientation: {dip.ori[0]}")
```

**Example 11: Beamforming with Accurate Forward Model**

```python
from mne.beamformer import make_lcmv, apply_lcmv

# Beamforming requires accurate forward model from OpenMEEG

# Compute spatial filters
filters = make_lcmv(
    evoked.info,
    fwd,
    data_cov,  # Data covariance
    reg=0.05,
    noise_cov=noise_cov,
    pick_ori='max-power'
)

# Apply to evoked data
stc_lcmv = apply_lcmv(evoked, filters, max_ori_out='signed')

# Visualize beamformer result
stc_lcmv.plot(
    subject=subject,
    subjects_dir=subjects_dir,
    hemi='both',
    initial_time=0.08
)
```

## Advanced Features

**Example 12: Anisotropic White Matter Conductivity**

```python
# White matter has anisotropic conductivity (conducts better along fibers)
# Requires DTI for fiber orientation

# Note: Anisotropic modeling is experimental in OpenMEEG
# Typically requires custom BEM solution computation

# Example tensor for white matter
# conductivity_wm = np.array([
#     [0.14, 0, 0],      # Radial
#     [0, 0.14, 0],      # Radial
#     [0, 0, 0.84]       # Along fibers (6x higher)
# ])

# This requires advanced setup beyond standard OpenMEEG
```

**Example 13: Volume Source Space**

```python
# Instead of cortical surface sources, use volumetric grid

# Create volume source space
volume_src = mne.setup_volume_source_space(
    subject=subject,
    pos=10.0,  # 10mm grid spacing
    bem=bem_solution,
    subjects_dir=subjects_dir
)

# Compute forward solution for volume sources
fwd_vol = mne.make_forward_solution(
    raw.info,
    trans='sub-001-trans.fif',
    src=volume_src,
    bem=bem_solution,
    meg=True,
    eeg=True
)

print(f"Volume sources: {fwd_vol['nsource']}")
```

**Example 14: Validation Against Analytical Solution**

```python
# Validate OpenMEEG against sphere model (analytical solution)

# Create sphere model
sphere = mne.make_sphere_model(
    r0=(0.0, 0.0, 0.0),  # Sphere center
    head_radius=0.09,  # 9cm radius
    relative_radii=(0.90, 0.92, 0.97, 1.0),  # Brain, CSF, Skull, Scalp
    sigmas=(0.3, 1.7, 0.006, 0.3)  # Conductivities
)

# Compute forward with sphere model
fwd_sphere = mne.make_forward_solution(
    raw.info,
    trans='sub-001-trans.fif',
    src=src,
    bem=sphere,
    meg=True,
    eeg=True
)

# Compare lead fields
leadfield_openmeeg = fwd['sol']['data']
leadfield_sphere = fwd_sphere['sol']['data']

# Compute correlation
from scipy.stats import pearsonr
corr, _ = pearsonr(
    leadfield_openmeeg.flatten(),
    leadfield_sphere.flatten()
)

print(f"Lead field correlation (OpenMEEG vs Sphere): {corr:.3f}")
# High correlation (>0.95) indicates good agreement
```

## Quality Control and Validation

**Example 15: Check Surface Quality**

```python
# Verify BEM surfaces don't intersect and are properly ordered

def check_bem_surfaces(bem_model):
    """Check BEM surface quality."""
    for i, surf in enumerate(bem_model):
        # Check for self-intersections
        tris = surf['tris']
        rr = surf['rr']

        # Compute surface normals
        v0 = rr[tris[:, 0]]
        v1 = rr[tris[:, 1]]
        v2 = rr[tris[:, 2]]

        normals = np.cross(v1 - v0, v2 - v0)
        normals /= np.linalg.norm(normals, axis=1, keepdims=True)

        # Check normal directions (should point outward)
        centers = (v0 + v1 + v2) / 3
        center_to_origin = -centers
        dot_products = np.sum(normals * center_to_origin, axis=1)

        outward_fraction = (dot_products > 0).mean()
        print(f"Surface {i}: {outward_fraction*100:.1f}% normals point outward")

        if outward_fraction < 0.9:
            print(f"  WARNING: Surface may have incorrect orientation")

check_bem_surfaces(bem_model)
```

**Example 16: Visualize Forward Solution Sensitivity**

```python
# Plot sensitivity map (sum of lead field magnitudes)
import numpy as np
import matplotlib.pyplot as plt

# Compute sensitivity for each source
leadfield = fwd['sol']['data']
n_sources = fwd['nsource']

sensitivity = np.zeros(n_sources)
for i in range(n_sources):
    lf = leadfield[:, i*3:(i+1)*3]
    sensitivity[i] = np.linalg.norm(lf)

# Create source estimate for visualization
vertices = [src[0]['vertno'], src[1]['vertno']]
stc_sensitivity = mne.SourceEstimate(
    sensitivity[:, np.newaxis],
    vertices=vertices,
    tmin=0,
    tstep=1,
    subject=subject
)

# Plot
brain = stc_sensitivity.plot(
    subject=subject,
    subjects_dir=subjects_dir,
    hemi='both',
    title='Forward Solution Sensitivity',
    clim=dict(kind='percent', lims=[50, 75, 95])
)
```

**Example 17: Compare MEG and EEG Sensitivity**

```python
# Extract MEG and EEG lead fields separately
picks_meg = mne.pick_types(fwd['info'], meg=True, eeg=False)
picks_eeg = mne.pick_types(fwd['info'], meg=False, eeg=True)

leadfield_meg = fwd['sol']['data'][picks_meg, :]
leadfield_eeg = fwd['sol']['data'][picks_eeg, :]

# Compute sensitivity
sens_meg = np.array([np.linalg.norm(leadfield_meg[:, i*3:(i+1)*3])
                     for i in range(n_sources)])
sens_eeg = np.array([np.linalg.norm(leadfield_eeg[:, i*3:(i+1)*3])
                     for i in range(n_sources)])

# Ratio of MEG to EEG sensitivity
ratio = sens_meg / (sens_eeg + 1e-10)

print(f"Mean MEG/EEG sensitivity ratio: {ratio.mean():.2f}")

# MEG typically more sensitive to superficial sources
# EEG can detect deeper sources better
```

## Parallel Processing and Optimization

**Example 18: Parallel Forward Computation**

```python
# Compute forward solutions for multiple subjects in parallel

from joblib import Parallel, delayed
import os

subjects = ['sub-001', 'sub-002', 'sub-003', 'sub-004']

def compute_forward_subject(subject):
    """Compute forward solution for one subject."""
    print(f"Processing {subject}")

    # Load BEM
    bem = mne.read_bem_solution(
        f'{subjects_dir}/{subject}/bem/{subject}-bem-sol.fif'
    )

    # Source space
    src = mne.read_source_spaces(
        f'{subjects_dir}/{subject}/bem/{subject}-oct6-src.fif'
    )

    # Raw info
    raw = mne.io.read_raw_fif(f'{subject}_raw.fif', preload=False)

    # Forward solution
    fwd = mne.make_forward_solution(
        raw.info,
        trans=f'{subject}-trans.fif',
        src=src,
        bem=bem,
        meg=True,
        eeg=True,
        n_jobs=1  # Single core per subject
    )

    # Save
    mne.write_forward_solution(f'{subject}-fwd.fif', fwd)
    return f"{subject} complete"

# Process in parallel (4 subjects simultaneously)
results = Parallel(n_jobs=4)(
    delayed(compute_forward_subject)(subj) for subj in subjects
)

for result in results:
    print(result)
```

**Example 19: Memory-Efficient Lead Field Computation**

```python
# For very large source spaces, compute lead fields in chunks

def compute_leadfield_chunked(fwd, chunk_size=1000):
    """Compute lead field matrix in chunks to save memory."""
    n_sources = fwd['nsource']
    n_channels = len(fwd['info']['ch_names'])

    # Pre-allocate (memory-mapped file)
    leadfield_file = 'leadfield.dat'
    leadfield = np.memmap(
        leadfield_file,
        dtype='float32',
        mode='w+',
        shape=(n_channels, 3*n_sources)
    )

    # Compute in chunks
    for start in range(0, n_sources, chunk_size):
        end = min(start + chunk_size, n_sources)
        print(f"Computing sources {start} to {end}")

        # Extract chunk from forward solution
        leadfield[:, start*3:end*3] = fwd['sol']['data'][:, start*3:end*3]

        # Flush to disk
        leadfield.flush()

    return leadfield

# Usage for large source spaces
# leadfield = compute_leadfield_chunked(fwd)
```

## Troubleshooting

### Common Errors and Solutions

**Surface Intersection Errors:**
```python
# Error: BEM surfaces intersect
# Solution: Check FreeSurfer segmentation

# Visualize surfaces
mne.viz.plot_bem(subject=subject, subjects_dir=subjects_dir)

# If surfaces intersect:
# 1. Rerun FreeSurfer with manual edits
# 2. Use lower ico resolution (ico=3 instead of ico=4)
# 3. Adjust watershed parameters
```

**Numerical Instabilities:**
```bash
# Error: Singular matrix or poor condition number
# Solutions:

# 1. Check surface mesh quality
om_check_geom head_model.geom

# 2. Use double precision
om_assemble -DoublePrec ...

# 3. Increase mesh resolution
# ico=4 (5120 triangles) instead of ico=5 (20480 triangles)
```

**Memory Issues:**
```python
# For large forward models:

# 1. Reduce source space density
src = mne.setup_source_space(
    subject=subject,
    spacing='oct5',  # Instead of oct6
    subjects_dir=subjects_dir
)

# 2. Use sparse lead field computation
# 3. Process in chunks (see Example 19)
# 4. Increase system RAM or use HPC
```

**Trans File Errors:**
```python
# Error: Cannot find trans file
# Solution: Coregister manually

# Use MNE coregistration GUI
mne.gui.coregistration(subject=subject, subjects_dir=subjects_dir)

# Or use automated coregistration
trans = mne.coreg.compute_source_morph_subject_correlation(
    subject_from=subject,
    subject_to='fsaverage',
    subjects_dir=subjects_dir
)
```

## Best Practices

**Tissue Conductivity Values:**
```python
# Standard conductivity values (S/m)
conductivities = {
    'brain': 0.3,
    'csf': 1.7,        # High conductivity
    'skull': 0.006,    # Low conductivity (100:1 ratio)
    'scalp': 0.3
}

# For neonates/infants, use different values:
# skull: 0.3 (not yet fully ossified)

# 3-layer (most common): brain, skull, scalp
conductivity_3layer = (0.3, 0.006, 0.3)

# 4-layer (more accurate): brain, csf, skull, scalp
conductivity_4layer = (0.3, 1.7, 0.006, 0.3)
```

**Mesh Resolution:**
```python
# Ico subdivision levels:
# ico=2: 320 triangles (fast, low accuracy)
# ico=3: 1280 triangles (moderate)
# ico=4: 5120 triangles (recommended for most studies)
# ico=5: 20480 triangles (high accuracy, slow)

# Higher resolution needed for:
# - High-frequency activity (>50 Hz)
# - Precise dipole fitting
# - Small sources (e.g., hippocampus)

# Use ico=4 for standard studies
```

**Source Space Density:**
```python
# Spacing levels:
# 'oct4': ~15mm spacing (~600 sources/hemisphere)
# 'oct5': ~9mm spacing (~1200 sources/hemisphere)
# 'oct6': ~5mm spacing (~4000 sources/hemisphere)

# Recommendations:
# - MEG: oct5 or oct6
# - EEG: oct5 (EEG has lower spatial resolution)
# - Distributed source imaging: oct6
# - Dipole fitting: oct5
```

**Validation:**
```python
# Always validate forward solution:

# 1. Visual inspection
mne.viz.plot_alignment(
    raw.info,
    trans=trans,
    subject=subject,
    subjects_dir=subjects_dir,
    surfaces='head-dense',
    meg='helmet',
    eeg='projected'
)

# 2. Check condition number
cond = np.linalg.cond(fwd['sol']['data'])
print(f"Condition number: {cond:.2e}")
# Should be < 1e10 for well-posed problem

# 3. Compare to analytical model (see Example 14)
```

## Integration with Analysis Ecosystem

**MNE-Python:**
- Primary interface for OpenMEEG
- Seamless integration via `make_bem_solution(solver='openmeeg')`
- Full source imaging pipeline

**FieldTrip (MATLAB):**
```matlab
% Use OpenMEEG in FieldTrip
cfg = [];
cfg.method = 'openmeeg';
cfg.headmodel = headmodel;
leadfield = ft_prepare_leadfield(cfg);
```

**Brainstorm:**
- Can use OpenMEEG for forward modeling
- Import BEM surfaces and compute lead fields
- GUI-based workflow

**FreeSurfer:**
- Provides anatomical segmentation
- Creates BEM surfaces via watershed algorithm
- Essential preprocessing step

## References

**OpenMEEG:**
- Gramfort et al. (2010). OpenMEEG: opensource software for quasistatic bioelectromagnetics. *BioMedical Engineering OnLine*, 9(1), 45.
- Kybic et al. (2005). A common formalism for the integral formulations of the forward EEG problem. *IEEE TMI*, 24(1), 12-28.

**BEM Methodology:**
- Hämäläinen & Sarvas (1989). Realistic conductivity geometry model of the human head for interpretation of neuromagnetic data. *IEEE BME*, 36(2), 165-171.
- Oostendorp & van Oosterom (1989). The surface Laplacian of the potential: Theory and application. *IEEE BME*, 43-52.

**Applications:**
- Baillet et al. (2001). Electromagnetic brain mapping. *IEEE Signal Processing Magazine*, 18(6), 14-30.
- Mosher et al. (1999). EEG and MEG: Forward solutions for inverse methods. *IEEE BME*, 46(3), 245-259.

**Online Resources:**
- OpenMEEG Website: http://openmeeg.github.io/
- OpenMEEG GitHub: https://github.com/openmeeg/openmeeg
- MNE-Python Forward Modeling: https://mne.tools/stable/auto_tutorials/forward/index.html
- FieldTrip Forward Problem: https://www.fieldtriptoolbox.org/tutorial/headmodel_eeg_bem/
